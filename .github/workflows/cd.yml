name: CD                                      # Workflow name shown in GitHub Actions UI

'on':
  workflow_call:                 # Enables this workflow to be called by other workflows ("reusable workflow")
    inputs:
      tag_name:                  # Input provided by the caller; accessible as inputs.tag_name inside this workflow
        required: true           # Caller must supply this input or the call will fail
        type: string             # Treat as a string (e.g., "v1.2.3"); types allowed: string, number, boolean, etc.

permissions:                                  # Permissions granted to the GITHUB_TOKEN
  contents: write                              # Allow updating release assets, etc.
  packages: write                               # Allow pushing images to GitHub Container Registry (GHCR)

concurrency:                                  # Prevent overlapping runs for the same ref
  group: cd-${{ inputs.tag_name }}             # Group key = "cd-" + tag name
  cancel-in-progress: true                     # Cancel any prior run in the same group

jobs:                                         # Top-level collection of jobs
  publish:                                    # Single job named "publish"
    runs-on: ubuntu-latest                     # Execute on the latest Ubuntu runner
    steps:                                     # Sequence of steps in this job
      - name: Checkout
        uses: actions/checkout@v4               # Clone the repository at the commit for the release
        with:
          ref: ${{ inputs.tag_name }}
          fetch-depth: 0                        # ensures the tag is fetchable in all cases

      - name: Compute NS (lowercase)            # Compute NS and ensure lowercase to avoid issues
        id: ns
        run: echo "ns=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      - name: Derive metadata
        id: meta
        run: |                                  # Write "version" to GITHUB_OUTPUT for use as steps.meta.outputs.version
            echo "version=${{ github.event.release.tag_name }}" >> "$GITHUB_OUTPUT"

      - name: Prepare .env for build (PYTHON_VERSION / PREFECT_VERSION)
        run: python scripts/derive_env_from_pyproject.py

      - name: Log in to GHCR
        uses: docker/login-action@v3            # Docker login action
        with:
          registry: ghcr.io                     # Target registry = GitHub Container Registry
          username: ${{ github.actor }}         # Use the GitHub user triggering the workflow
          password: ${{ secrets.GITHUB_TOKEN }}  # Built-in token with write permission to GHCR

      - name: Install yq
        run: |                                  # Install the yq YAML processor
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      # Determine which services are custom builds, and reuse this determination to avoid redundancy
      - name: Resolve buildable services
        id: svc
        shell: bash
        run: |
          set -euo pipefail
          svcs=$(docker compose config \
            | yq e -r '.services
                      | to_entries
                      | map(select(.value.build) | .key)
                      | join(" ")')
          echo "list=$svcs" >> "$GITHUB_OUTPUT"

      # Build only services that have `build:` to avoid postgres/redis, etc.
      - name: Build app images (compose)
        if: ${{ steps.svc.outputs.list != '' }}
        shell: bash
        run: |                                # Build all local services described in docker-compose.yml
          set -euo pipefail
          for svc in ${{ steps.svc.outputs.list }}; do  # Reusing list from above
            docker compose build --pull "$svc"
          done

      # Tag and push each service image: ghcr.io/owner/repo-<service>:<version> and :latest
      - name: Tag & push app images
        if: ${{ steps.svc.outputs.list != '' }}
        shell: bash
        env:                                  # Job-wide environment variables
          NS: ${{ steps.ns.outputs.ns }}      # Base image namespace, e.g. ghcr.io/owner/repo
          VERSION: ${{ steps.meta.outputs.version }}  # Use output version generated above
        run: |                                # Shell script to tag/push each service image
          set -euo pipefail                   # Exit on error/undefined vars/pipe fails
          for svc in ${{ steps.svc.outputs.list }}; do  # Reusing list from above
            id=$(docker compose images --quiet "$svc")  # Get the built image ID
            docker tag "$id" "${NS}-${svc}:${VERSION}"  # Versioned tag
            docker tag "$id" "${NS}-${svc}:latest"      # 'latest' tag
            docker push "${NS}-${svc}:${VERSION}"       # Push versioned image
            docker push "${NS}-${svc}:latest"           # Push latest image
          done

      # Produce a pinned, pull-only compose file for deployment:
      # For any service that has build:, set image: ghcr.io/owner/repo-<service>:<version> and remove build:
      - name: Pin compose to release tag
        env:
          VERSION: ${{ steps.meta.outputs.version }}  # Carry forward env vars for clarity
          NS: ${{ steps.ns.outputs.ns }}
        shell: bash
        run: |                                  # Rewrite docker-compose.yml with fixed images
            set -euo pipefail
            yq e '
            .services |= with_entries(          # For each service entry…
                if (.value | has("build")) then  # If it has a local build context…
                .value |= (
                    .image = (strenv(NS) + "-" + .key + ":" + strenv(VERSION))  # Set image field
                    | del(.build)               # Remove the build directive
                )
                else
                .                               # Otherwise leave unchanged
                end
            )
            ' docker-compose.yml > "docker-compose.${VERSION}.yml"  # Output pinned file

      - name: Upload pinned compose to release
        uses: softprops/action-gh-release@v2     # Add file to the GitHub release assets
        with:
          tag_name: ${{ steps.meta.outputs.version }}   # Attach to the current release tag
          files: docker-compose.${{ steps.meta.outputs.version }}.yml  # Upload the pinned compose file
