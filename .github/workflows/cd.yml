name: CD                                      # Workflow name shown in GitHub Actions UI

'on':
  workflow_call:                 # Enables this workflow to be called by other workflows ("reusable workflow")
    inputs:
      tag_name:                  # Input provided by the caller; accessible as inputs.tag_name inside this workflow
        required: true           # Caller must supply this input or the call will fail
        type: string             # Treat as a string (e.g., "v1.2.3"); types allowed: string, number, boolean, etc.

permissions:                                  # Permissions granted to the GITHUB_TOKEN
  contents: write                              # Allow updating release assets, etc.
  packages: write                               # Allow pushing images to GitHub Container Registry (GHCR)

concurrency:                                  # Prevent overlapping runs for the same ref
  group: cd-${{ inputs.tag_name }}             # Group key = "cd-" + tag name
  cancel-in-progress: true                     # Cancel any prior run in the same group

jobs:                                         # Top-level collection of jobs
  publish:                                    # Single job named "publish"
    runs-on: ubuntu-latest                     # Execute on the latest Ubuntu runner
    steps:                                     # Sequence of steps in this job
      - name: Checkout
        uses: actions/checkout@v4               # Clone the repository at the commit for the release
        with:
          ref: ${{ inputs.tag_name }}
          fetch-depth: 0                        # ensures the tag is fetchable in all cases

      - name: Compute NS (lowercase)            # Compute NS and ensure lowercase to avoid issues
        id: ns
        run: echo "ns=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      - name: Derive metadata
        id: meta
        run: |                                  # Write "version" to GITHUB_OUTPUT for use as steps.meta.outputs.version
          echo "version=${{ inputs.tag_name }}" >> "$GITHUB_OUTPUT"

      - name: Export build versions (PYTHON_VERSION / PREFECT_VERSION)
        run: bash scripts/export_build_versions.sh --github-env >> "$GITHUB_ENV"

      - name: Log in to GHCR
        uses: docker/login-action@v3            # Docker login action
        with:
          registry: ghcr.io                     # Target registry = GitHub Container Registry
          username: ${{ github.actor }}         # Use the GitHub user triggering the workflow
          password: ${{ secrets.GITHUB_TOKEN }}  # Built-in token with write permission to GHCR

      - name: Install yq
        run: |                                  # Install the yq YAML processor
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      # Determine which services are custom builds, and reuse this determination to avoid redundancy
      - name: Resolve buildable services and images
        id: svc
        shell: bash
        run: |
          set -euo pipefail
          svcs=$(yq -r '.services
                      | to_entries
                      | map(select(.value.build) | "\(.key)\t\(.value.image // .key)")
                      | .[]' docker-compose.yml \
                | awk -F'\t' '!seen[$2]++ {print $1}' \
                | tr '\n' ' ' | sed 's/ $//')
          imgs=$(yq -r '.services
                      | to_entries
                      | map(select(.value.build) | (.value.image // .key))
                      | unique
                      | join(" ")' docker-compose.yml)
          echo "list=$svcs" >> "$GITHUB_OUTPUT"
          echo "images=$imgs" >> "$GITHUB_OUTPUT"

      # Build only services that have `build:` to avoid postgres/redis, etc.
      - name: Build app images (compose)
        if: ${{ steps.svc.outputs.list != '' }}
        shell: bash
        run: |                                # Build all local services described in docker-compose.yml
          set -euo pipefail
          export COMPOSE_PROFILES="datapipe-core,datapipe-visualize-data,nginx-local,nginx-prod"
          for svc in ${{ steps.svc.outputs.list }}; do  # Reusing list from above
            docker compose build --pull "$svc"
          done

      # Tag and push each custom service image: ghcr.io/owner/repo-<service>:<version> and :latest
      # Logic to ensure correct image names are sourced to avoid nulls
      - name: Tag & push app images
        if: ${{ steps.svc.outputs.images != '' }}
        shell: bash
        env:                                  # Job-wide environment variables
          NS: ${{ steps.ns.outputs.ns }}      # Base image namespace, e.g. ghcr.io/owner/repo
          VERSION: ${{ steps.meta.outputs.version }}  # Use output version generated above
        run: |                                # Shell script to tag/push each service image
          set -euo pipefail                   # Exit on error/undefined vars/pipe fails
          for img in ${{ steps.svc.outputs.images }}; do  # Reusing unique image list from above
            if docker image inspect "${img}:latest" >/dev/null 2>&1; then
              id="${img}:latest"
            else
              id="$(docker image ls --format '{{.Repository}}:{{.Tag}}' \
                    | awk -F: -v img="$img" '$1==img {print; exit}' || true)"
            fi

            if [ -z "${id}" ]; then
              echo "No built image found for image: $img" >&2
              exit 1
            fi

            echo "FOUND $img -> $id"
            docker tag "$id" "${NS}-${img}:${VERSION}"  # Versioned tag
            docker tag "$id" "${NS}-${img}:latest"      # 'latest' tag
            docker push "${NS}-${img}:${VERSION}"       # Push versioned image
            docker push "${NS}-${img}:latest"           # Push latest image
          done

      # Produce a pinned, pull-only compose file for deployment:
      # For any service that has build:, set image: ghcr.io/owner/repo-<service>:<version> and remove build:
      - name: Pin compose to release tag
        env:
          VERSION: ${{ steps.meta.outputs.version }}  # Carry forward env vars for clarity
          NS: ${{ steps.ns.outputs.ns }}
        shell: bash
        run: |
            set -euo pipefail
            [[ -n "${VERSION:-}" ]] || { echo "VERSION is empty"; exit 1; }

            EXPR=$(cat <<'YQ'
            .services |= with_entries(
              (. as $e
               | (
                   select(.value | has("build"))
                   | .value.image = (strenv(NS) + "-" + (.value.image // .key) + ":" + strenv(VERSION))
                   | del(.value.build)
                 ) // $e
              )
            )
            YQ
            )

            yq eval "$EXPR" docker-compose.yml > "docker-compose.${VERSION}.yml"

      - name: Upload pinned compose to release
        uses: softprops/action-gh-release@v2     # Add file to the GitHub release assets
        with:
          tag_name: ${{ steps.meta.outputs.version }}   # Attach to the current version
          files: |                # Upload the pinned compose file, readme, and license to release
            docker-compose.${{ steps.meta.outputs.version }}.yml
            .env.example
            README-QUICKSTART.md
            LICENSE.md
            run/stockops.sh
            nginx/host/stockops-host.conf.template
          body_path: README-QUICKSTART.md        # makes the release description this README
