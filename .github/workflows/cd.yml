name: CD                                      # Workflow name shown in GitHub Actions UI

'on':  # Event triggers for this workflow
  release:  # Trigger on a GitHub Release event
    types: [published]  # Only run when a release is published

permissions:                                  # Permissions granted to the GITHUB_TOKEN
  contents: write                              # Allow updating release assets, etc.
  packages: write                               # Allow pushing images to GitHub Container Registry (GHCR)

concurrency:                                  # Prevent overlapping runs for the same ref
  group: cd-${{ github.ref }}                  # Group key = "cd-" + branch or tag name
  cancel-in-progress: true                     # Cancel any prior run in the same group

jobs:                                         # Top-level collection of jobs
  publish:                                    # Single job named "publish"
    runs-on: ubuntu-latest                     # Execute on the latest Ubuntu runner
    steps:                                     # Sequence of steps in this job
      - name: Checkout
        uses: actions/checkout@v4               # Clone the repository at the commit for the release
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Compute NS (lowercase)            # Compute NS and ensure lowercase to avoid issues
        id: ns
        run: echo "ns=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      - name: Derive metadata
        id: meta
        run: |                                  # Write "version" to GITHUB_OUTPUT for use as steps.meta.outputs.version
            echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Prepare .env for build (PYTHON_VERSION / PREFECT_VERSION)
        run: python scripts/derive_env_from_pyproject.py

      - name: Log in to GHCR
        uses: docker/login-action@v3            # Docker login action
        with:
          registry: ghcr.io                     # Target registry = GitHub Container Registry
          username: ${{ github.actor }}         # Use the GitHub user triggering the workflow
          password: ${{ secrets.GITHUB_TOKEN }}  # Built-in token with write permission to GHCR

      - name: Install yq
        run: |                                  # Install the yq YAML processor
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      # Determine which services are custom builds, and reuse this determination to avoid redundancy
      - name: Resolve buildable services
        id: svc
        shell: bash
        run: |
          set -euo pipefail
          svcs=$(docker compose config \
            | yq -r '.services
                      | to_entries
                      | map(select(.value.build) | .key)
                      | join(" ")')
          echo "list=$svcs" >> "$GITHUB_OUTPUT"

      # Determine if this is a release triggered run to avoid multiple actions
      - name: Should skip heavy steps (is this release-please bot?)
        id: guard
        run: |
          if [ "${{ github.actor }}" = "release-please[bot]" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi


      # Build only services that have `build:` to avoid postgres/redis, etc.
      - name: Build app images (compose)
        if: ${{ steps.guard.outputs.skip != 'true' && steps.svc.outputs.list != '' }}
        shell: bash
        run: |                                # Build all local services described in docker-compose.yml
          set -euo pipefail
          for svc in ${{ steps.svc.outputs.list }}; do  # Reusing list from above
            docker compose build --pull "$svc"
          done

      # Tag and push each service image: ghcr.io/owner/repo-<service>:<version> and :latest
      - name: Tag & push app images
        if: ${{ steps.guard.outputs.skip != 'true' && steps.svc.outputs.list != '' }}
        shell: bash
        env:                                  # Job-wide environment variables
          NS: ${{ steps.ns.outputs.ns }}      # Base image namespace, e.g. ghcr.io/owner/repo
          VERSION: ${{ steps.meta.outputs.version }}  # Use output version generated above
        run: |                                # Shell script to tag/push each service image
          set -euo pipefail                   # Exit on error/undefined vars/pipe fails
          for svc in ${{ steps.svc.outputs.list }}; do  # Reusing list from above
            id=$(docker compose images --quiet "$svc")  # Get the built image ID
            docker tag "$id" "${NS}-${svc}:${VERSION}"  # Versioned tag
            docker tag "$id" "${NS}-${svc}:latest"      # 'latest' tag
            docker push "${NS}-${svc}:${VERSION}"       # Push versioned image
            docker push "${NS}-${svc}:latest"           # Push latest image
          done

      # Produce a pinned, pull-only compose file for deployment:
      # For any service that has build:, set image: ghcr.io/owner/repo-<service>:<version> and remove build:
      - name: Pin compose to release tag
        env:
          VERSION: ${{ steps.meta.outputs.version }}  # Carry forward env vars for clarity
          NS: ${{ steps.ns.outputs.ns }}
        run: |                                  # Rewrite docker-compose.yml with fixed images
          yq -y '
            .services |= with_entries(           # For each service entry…
              if .value.build then               # If it has a local build context…
                .value.image = (strenv(NS) + "-" + .key + ":" + strenv(VERSION)) | # Set image field
                del(.value.build)                # Remove the build directive
              else
                .                                # Otherwise leave unchanged
              end
            )
          ' docker-compose.yml > "docker-compose.${VERSION}.yml"   # Output pinned file

      - name: Upload pinned compose to release
        uses: softprops/action-gh-release@v2     # Add file to the GitHub release assets
        with:
          tag_name: ${{ steps.meta.outputs.version }}   # Attach to the current release tag
          files: docker-compose.${{ steps.meta.outputs.version }}.yml  # Upload the pinned compose file
