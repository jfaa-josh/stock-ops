name: stockops

# Grab .env file for environment variables
x-common-envfile: &common-envfile
  env_file:
    - ${ENV_FILE:-.env}

# Anchor for the shared Prefect env vars
x-common-envvars: &common-envvars
  ENV: production                                     # Set environment to production so you skip load_dotenv()
  PREFECT_DEFAULT_WORK_POOL_NAME: default             # Default work pool for Prefect tasks

services:
  ###BASELINE SERVICES ALWAYS ON >>>>>>>>>>>>>>>>>>>>>>>>>>>
  init-db-permissions:                                # A quick service to set permissions for app/data volume
    image: busybox:1.37.0-glibc                       # Lightweight container image for running simple shell commands
    user: "0:0"                                       # Run as root (UID 0, GID 0) to allow modifying permissions
    volumes:
      - db_data:/app/data                             # Mount named volume `db_data` to /app/data inside the container
    command:                                          # Command executed when the container starts
      [                                               # Change ownership recursively to UID/GID 1000 (non-root user)
        "sh", "-c",
        "chown -R 1000:1000 /app/data && \
         find /app/data -type d -exec chmod 2770 {} + && \
         find /app/data -type f -exec chmod 0660 {} +"  # Set dirs to group-write, with setgid bit for inherited grp
      ]                                                # Set files to user/group readable/writable, no access for others
    restart: "no"

  postgres:                                           # PostgreSQL database service to store metadata for containers
    image: postgres:17                                # Use Postgres version 17 image
    environment:                                      # Set database credentials
      POSTGRES_USER: prefect                          # Username for the DB
      POSTGRES_PASSWORD: prefect                      # Password for the DB
      POSTGRES_DB: prefect                            # Default database name
    volumes:
      - postgres_data:/var/lib/postgresql/data        # Persist data on host volume
    healthcheck:                                      # Check DB readiness
      test: ["CMD-SHELL", "pg_isready -U prefect"]    # Command to test if Postgres is ready
      interval: 5s                                    # Time between checks
      timeout: 5s                                     # How long to wait per check
      retries: 5

  redis:                                              # Redis cache/service for message brokering between containers
    image: redis:8                                    # Use Redis version 8 image
    volumes:
      - redis_data:/data                              # Persist Redis data on host volume
    healthcheck:                                      # Check Redis readiness
      test: ["CMD-SHELL", "redis-cli ping"]           # Command to ping Redis
      interval: 5s                                    # Check every 5 seconds
      timeout: 5s                                     # Timeout per check
      retries: 5                                      # Number of retries before marking unhealthy

  nginx-prod:                                             # Reverse proxy for UI services -> single entrypoint
    image: stockops-nginx                              # Custom nginx image with baked configs/certs
    build:
      context: .
      dockerfile: docker/Dockerfile.nginx
    container_name: nginx                             # Fixed container name for easier docker ps grepping
    <<: *common-envfile
    depends_on:
      certbot-init:
        condition: service_completed_successfully
      streamlit:
        condition: service_started                    # Delay nginx until the Streamlit UI is ready
    ports:
      - "80:80"                                       # Serve HTTP on host port 80
      - "443:443"                                     # Serve HTTPS on host port 443
    profiles: ["nginx-prod"]
    environment:
      NGINX_ENVSUBST_TEMPLATE_DIR: /etc/nginx/templates-prod
    volumes:
      - certs_prod:/etc/letsencrypt:ro                   # TLS certs persisted in named volume
      - certs_www:/var/www/certbot:ro
      - ./secrets/prod.htpasswd:/etc/nginx/prod/htpasswd:ro  # Production htpasswd file (host-managed)
    restart: unless-stopped                           # Auto-restart unless explicitly stopped
    command: ["/bin/sh", "-c", "/scripts/nginx-reload-loop.sh & exec /scripts/nginx-entrypoint.sh"]
    healthcheck:
      test: ["CMD-SHELL", "wget -q --server-response --spider --no-check-certificate https://127.0.0.1/ 2>&1 | awk '/^  HTTP/{code=$2} END{exit (code==200||code==301||code==302||code==401)?0:1}'"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  nginx-local:
    image: stockops-nginx
    build:
      context: .
      dockerfile: docker/Dockerfile.nginx
    container_name: nginx-local
    depends_on:
      init-htpasswd-local:
        condition: service_completed_successfully
      streamlit:
        condition: service_started
    ports:
      - "80:80"
      - "443:443"
    profiles: ["nginx-local"]
    environment:
      NGINX_ENVSUBST_TEMPLATE_DIR: /etc/nginx/templates-local
    volumes:
      - nginx_local_auth:/etc/nginx-local:rw
    restart: unless-stopped
    command: ["/bin/sh", "-c", "exec /scripts/nginx-entrypoint.sh"]
    healthcheck:
      test: ["CMD-SHELL", "wget -q --server-response --spider --no-check-certificate https://127.0.0.1/ 2>&1 | awk '/^  HTTP/{code=$2} END{exit (code==200||code==301||code==302||code==401)?0:1}'"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  ###DATA PIPELINE CORE SERVICES >>>>>>>>>>>>>>>>>>>>>>>>>>>
  writer-service:                                     # Defines the buffer & sqlite writer-service container
    <<: *common-envfile                               # Load common .env file for environment variables
    build:                                            # Build a custom image ahead of runtime
      context: .                                      # └─ use this repo as build context
      dockerfile: docker/Dockerfile.writer            # └─ path to our optimized server Dockerfile
      args:                                           # └─ pass your version args into the build
        PYTHON_VERSION: ${PYTHON_VERSION}
    image: writer-service                             # Tag for the built image
    depends_on:
      redis:
        condition: service_healthy                    # Wait for Redis to be ready
      init-db-permissions:                            # Ensure permissions to access files in db
        condition: service_completed_successfully
    user: "1000:1000"                                 # match sqlitebrowser’s PUID/PGID (avoiding access conflicts)
    profiles: ["datapipe-core"]                       # This service only starts with `--profile datapipe-core`
    environment:                                      # Define environment variables for the container
      <<: *common-envvars                             # Inherit common environment variables
      REDIS_URL: redis://redis:6379/1                 # Internal redis connex URL (host:port/db) (use DB1; prefect uses DB0)
      PYTHONDONTWRITEBYTECODE: 1                      # Prevents Python from writing __pycache__ clutter to container
      PYTHONUNBUFFERED: 1                             # Forces stdout/stderr logs to flush -> `docker logs` in real time
      BUFFER_STREAM: buf:ingest                       # Name of the Redis stream used for buffering ingest data
      DB_DATA_DIR: /app/data                          # Define src config var for docker .db storage dir
      BUFFER_BATCH: "500"                             # Max num messages pulled from Redis in a single batch
      BUFFER_BLOCK_MS: "10000"                        # Latency control: max ms buffer blocks while waiting for new messages
      BUFFER_TRIM_MAXLEN: "100000"                    # keep stream bounded (approximate)
    volumes:
      - db_data:/app/data                             # docker data directory for live .db file storage in the container
    command: ["/bin/sh", "-lc", "umask 0002 && exec python src/stockops/data/database/writer.py"]
    healthcheck:                                      # Health check for writer-service
      test: ["CMD-SHELL", "kill -0 1"]
      # └─ checks if the Python process for writer.py is running; exit 1 if not
      interval: 10s                                   # Run check every 10 seconds
      timeout: 5s                                     # Fail if it takes >5s
      retries: 5                                      # Mark unhealthy after 5 failed checks
      start_period: 10s                               # Give it 10s to warm up before checking

  prefect-server:                                     # Prefect API + services container
    <<: *common-envfile                               # Load common .env file for environment variables
    build:                                            # Build a custom image ahead of runtime
      context: .                                      # └─ use this repo as build context
      dockerfile: docker/Dockerfile.prefect-server    # └─ path to our optimized server Dockerfile
      args:                                           # └─ pass your version args into the build
        PYTHON_VERSION: ${PYTHON_VERSION}
        PREFECT_VERSION: ${PREFECT_VERSION}
    image: prefect-server                             # Tag for the built image
    working_dir: /app                                 # Run all commands from /app
    profiles: ["datapipe-core"]                       # This service only starts with `--profile datapipe-core`
    environment:                                      # Prefect configuration variables
      <<: *common-envvars                             # Inherit common environment variables
      # Connection string for Prefect → Postgres:
      PREFECT_API_DATABASE_CONNECTION_URL: postgresql+asyncpg://prefect:prefect@postgres:5432/prefect
      PREFECT_SERVER_API_HOST: 0.0.0.0                # Listen on every network interface
      PREFECT_API_URL: http://prefect-server:4200/api  # Internal API URL for Prefect services (not host-exposed)
      PREFECT_UI_SERVE_BASE: ${PREFECT_UI_SERVE_BASE:-/prefect}  # Base path for the UI
      PREFECT_UI_API_URL: ${PREFECT_UI_API_URL:-https://stockops.local/api}  # UI uses proxy URL
      PREFECT_LOGGING_LEVEL: DEBUG                    # Verbose logs for debugging
      PREFECT_MESSAGING_BROKER: prefect_redis.messaging   # Broker config for Prefect messaging
      PREFECT_MESSAGING_CACHE: prefect_redis.messaging    # Cache config for messaging
      PREFECT_REDIS_MESSAGING_HOST: redis             # Redis hostname for messaging
      PREFECT_REDIS_MESSAGING_PORT: 6379              # Docker internal Redis port
      PREFECT_REDIS_MESSAGING_DB: 0                   # Redis DB index
    depends_on:
      postgres:
        condition: service_healthy                    # Wait for Postgres to be ready
      redis:
        condition: service_healthy                    # Wait for Redis to be ready
    healthcheck:                                      # Verify the API comes up successfully
      test: [
        "CMD", "python", "-c",
        "import sys, urllib.request; u='http://127.0.0.1:4200/api/health'; ",
        "try:\n",
        "    r = urllib.request.urlopen(u, timeout=3)\n",
        "    sys.exit(0 if 200 <= r.status < 300 else 1)\n",
        "except Exception:\n",
        "    sys.exit(1)\n"
      ]
      interval: 5s                                    # Poll every 5 seconds
      timeout: 3s                                     # Timeout each check after 3 seconds
      retries: 10                                     # Try up to 10 times before marking unhealthy
      start_period: 5s                                # give the API a moment to come up

  prefect-serve:                                      # Prefect agent for local (no worker pool/no deployment)
    <<: *common-envfile                               # Load common .env file for environment variables
    build:
      context: .                                      # Docker build context is repo root
      args:
        PYTHON_VERSION: ${PYTHON_VERSION}             # Pass Python version to Dockerfile
        PREFECT_VERSION: ${PREFECT_VERSION}           # Pass Prefect version to Dockerfile
      dockerfile: docker/Dockerfile.prefect-serve     # Custom Dockerfile for executing deployment free flows
    image: prefect-serve                              # Name of the built image
    depends_on:
      prefect-server:
        condition: service_healthy                    # Wait until Prefect server is healthy
      writer-service:
        condition: service_healthy                    # Wait until writer-service is healthy
    profiles: ["datapipe-core"]                       # This service only starts with `--profile datapipe-core`
    environment:                                      # Prefect configuration variables
      <<: *common-envvars                             # Inherit common environment variables
      PREFECT_API_URL: http://prefect-server:4200/api  # API URL for the worker to pull jobs
      REDIS_URL: redis://redis:6379/1                 # Access to Redis DB1 for writer-service connect
      BUFFER_STREAM: buf:ingest                       # Env for Redis stream used by writer-service
      DB_DATA_DIR: /app/data                          # Define var to ref in src config to set paths for docker .db
                                # └─ Note: prefect-serve does not access .db; DB_DATA_DIR only for filepath creation
    command: >                                        # Create default pool (if missing); Start worker polling 'default'
      bash -c "
        prefect work-pool create default --type process --set-as-default || true &&
        prefect worker start --pool default --type process
      "
    healthcheck:                                      # Check if the Prefect worker is ready
      test: ["CMD-SHELL", "prefect work-pool inspect default"]
      interval: 10s                                   # Check every 10 seconds
      timeout: 5s                                     # Timeout each check after 5 seconds
      retries: 5                                      # Retry up to 5 times before marking unhealthy
      start_period: 10s                               # Wait 10 seconds before starting health checks

  streamlit:                                          # Streamlit UI container
    <<: *common-envfile                               # Load common .env file for environment variables
    build:
      context: .                                      # Build context is repo root
      args:
        PYTHON_VERSION: ${PYTHON_VERSION}             # Pass Python version to Dockerfile
      dockerfile: docker/Dockerfile.streamlit         # Custom Dockerfile for Streamlit
    image: streamlit                                  # Name of the built Streamlit image
    depends_on:
      prefect-serve:
        condition: service_healthy                    # Wait until Prefect server is ready
    profiles: ["datapipe-core"]                       # This service only starts with `--profile datapipe-core`
    environment:
      <<: *common-envvars                             # Inherit common environment variables
      PREFECT_API_URL: http://prefect-server:4200/api   # Prefect API URL for Streamlit to trigger flows
      VERBOSE_LOGGING: "false"                        # Sets streamlit_ui code var to reduce logging ("true"/"false")
      PYTHONPATH: /app:/app/src                       # Override .env's ./src to allow relative imports for pytest
    command: streamlit run datapipe_ui/frontend.py      # Launch the Streamlit application

  ###DATA PIPELINE OPTIONAL SERVICES >>>>>>>>>>>>>>>>>>>>>>>>>>>
  sqlitebrowser:
    # image: lscr.io/linuxserver/sqlitebrowser:latest   # LinuxServer.io's maintained image for DB Browser for SQLite
    image: docker.io/linuxserver/sqlitebrowser:version-3.13.1-r0
    attach: false                                     # Cuts out mindless logging chatter
    container_name: sqlitebrowser                     # Name shown in `docker ps` for easy reference
    depends_on:
      writer-service:                                 # Don't start until writer-service reports healthy
        condition: service_healthy
      init-db-permissions:                            # Ensure permissions to access files in db
        condition: service_completed_successfully
    profiles: ["datapipe-visualize-data"]             # Service only starts with `--profile datapipe-visualize-data`
    environment:
      - PUID=1000                                     # Host user ID (so container files have correct ownership)
      - PGID=1000                                     # Host group ID (same reason as above)
      - UMASK=002                                     # Validate runtim umask for file permissions conformity
      - TZ=Etc/UTC                                    # Set container timezone (affects logs, timestamps in UI)
    volumes:
      - sqlitebrowser_config:/config                  # Stores the app's own settings/config; persistent across restarts
      - db_data:/data                                 # Mount your named volume with SQLite .db files
    security_opt:
      - seccomp:unconfined                            # Relax default seccomp profile so GUI dependencies run properly
    restart: unless-stopped                           # Auto-restart unless you explicitly stop the container

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:v0.49.1
    container_name: cadvisor
    profiles: ["nginx-prod"]
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    restart: unless-stopped

  init-htpasswd-local:
    image: stockops-htpasswd
    build:
      context: .
      dockerfile: docker/Dockerfile.htpasswd
    profiles: ["nginx-local"]
    volumes:
      - nginx_local_auth:/etc/nginx-local:rw
    command: ["/bin/sh", "-c", "/bin/sh /scripts/init-htpasswd-local.sh /etc/nginx-local"]
    restart: "no"

  certbot-init:
    image: stockops-certbot
    build:
      context: .
      dockerfile: docker/Dockerfile.certbot
    profiles: ["nginx-prod"]
    <<: *common-envfile
    ports:
      - "80:80"
    volumes:
      - certs_prod:/etc/letsencrypt:rw
    entrypoint: ["/bin/sh", "-c"]
    command: "/scripts/certbot-init.sh"
    restart: "no"

  certbot:
    image: stockops-certbot
    build:
      context: .
      dockerfile: docker/Dockerfile.certbot
    profiles: ["nginx-prod"]
    depends_on:
      nginx-prod:
        condition: service_started
    <<: *common-envfile
    volumes:
      - certs_prod:/etc/letsencrypt:rw
      - certs_www:/var/www/certbot:rw
    entrypoint: ["/bin/sh", "-c"]
    command: "/scripts/certbot-renew.sh"
    restart: unless-stopped

volumes:                                              # Named Docker volumes for data persistence
  postgres_data:                                      # Holds Postgres data directory
  redis_data:                                         # Holds Redis data directory
  db_data:                                            # Holds .db database directory
  sqlitebrowser_config:                               # Holds config data for sqlitebrowser settings
  certs_prod:                                        # Persisted production certs
  certs_www:                                         # Webroot for certbot renewals
  nginx_local_auth:                                  # Local htpasswd storage
